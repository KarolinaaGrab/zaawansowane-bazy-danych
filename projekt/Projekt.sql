-- Projekt bazy danych: księgarnia
-- zarzadzanie ksiazkami, autorami, kategoriami
-- obluga klientow, zamowien, pozycji zamowien i platnosci
-- archiwizacja danych usunietych: autorzy, ksiazki, kategorie, klienci, zamowienia
-- walidacja danych (nr ISBN, email)
-- automatyczne przeliczanie wartosci zamowien (trigger)
-- zestawienie sprzedazowe (miesieczne, kwartalne, roczne)
-- wykorzystanie funkcji okienkowych do rankingow


SET SERVEROUTPUT ON;

CREATE TABLE authors (
    author_id       NUMBER PRIMARY KEY,
    first_name      VARCHAR2(50) NOT NULL,
    last_name       VARCHAR2(50) NOT NULL,
    birth_year      NUMBER(4),
    death_year      NUMBER(4),
    CONSTRAINT chk_author_years
        CHECK (
            death_year IS NULL OR birth_year IS NULL
            OR death_year > birth_year
        )
);

CREATE TABLE categories (
    category_id     NUMBER PRIMARY KEY,
    name            VARCHAR2(50) NOT NULL,
    description     VARCHAR2(200)
);

CREATE TABLE books (
    book_id         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title           VARCHAR2(200) NOT NULL,
    isbn            VARCHAR2(20) UNIQUE,
    author_id       NUMBER NOT NULL,
    category_id     NUMBER,
    price           NUMBER(10, 2) NOT NULL,
    stock_quantity  NUMBER NOT NULL,
    year_of_release NUMBER(4),
    CONSTRAINT fk_books_category FOREIGN KEY (category_id) REFERENCES categories (category_id),
    CONSTRAINT fk_books_author FOREIGN KEY (author_id) REFERENCES authors (author_id),
    CONSTRAINT chk_book_price CHECK (price > 0),
    CONSTRAINT chk_stock_quantity CHECK (stock_quantity >= 0)
);

CREATE TABLE customers (
    customer_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    first_name        VARCHAR2(50),
    last_name         VARCHAR2(50),
    email             VARCHAR2(100),
    registration_date DATE DEFAULT SYSDATE
);

CREATE TABLE orders (
    order_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id   NUMBER,
    status        VARCHAR2(20),
    total_amount  NUMBER(10, 2)
);

CREATE TABLE order_items (
    order_item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id      NUMBER NOT NULL,
    book_id       NUMBER NOT NULL,
    quantity      NUMBER NOT NULL,
    unit_price    NUMBER(10,2) NOT NULL
);

CREATE TABLE payments (
    payment_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id       NUMBER NOT NULL,
    payment_type   VARCHAR2(30),
    payment_status VARCHAR2(30),
    payment_date   DATE,
    amount         NUMBER(10,2)
);

ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer
FOREIGN KEY (customer_id) REFERENCES customers (customer_id);

ALTER TABLE orders
ADD CONSTRAINT chk_order_status
CHECK (status IN ('NEW', 'PAID', 'SHIPPED', 'CANCELLED'));

ALTER TABLE orders
MODIFY customer_id NUMBER NOT NULL;

ALTER TABLE orders
MODIFY status VARCHAR2(20) NOT NULL;

ALTER TABLE orders
MODIFY total_amount NUMBER(10,2) NOT NULL;

ALTER TABLE orders
ADD order_date DATE DEFAULT SYSDATE NOT NULL;

ALTER TABLE order_items
MODIFY unit_price NUMBER(10,2) DEFAULT NULL;

ALTER TABLE order_items
ADD CONSTRAINT fk_items_order
FOREIGN KEY (order_id) REFERENCES orders (order_id);

ALTER TABLE order_items
ADD CONSTRAINT fk_items_book
FOREIGN KEY (book_id) REFERENCES books (book_id);

ALTER TABLE payments
ADD CONSTRAINT fk_payments_order
FOREIGN KEY (order_id) REFERENCES orders(order_id);


-- tabele logujace inf do tabeli
-- archiwizacja
--
CREATE TABLE import_log (
    log_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name    VARCHAR2(50),
    file_name     VARCHAR2(100),
    raw_data      VARCHAR2(4000),
    status        VARCHAR2(20),   -- SUCCESS / ERROR
    message       VARCHAR2(200),
    created_at    DATE DEFAULT SYSDATE
);


-- ladowanie danych do bazy, kod w pythonie:
-- https://stackoverflow.com/questions/68601874/how-to-load-csv-file-to-oracle-table-in-faster-way-using-python

-- testy
select * FROM books;
select * from authors;
select * from categories;
select * from import_log;

DROP TABLE authors CASCADE constraints;
DROP TABLE categories CASCADE constraints;
DROP TABLE books CASCADE constraints;
DROP TABLE customers CASCADE constraints;
DROP TABLE orders CASCADE constraints;
DROP TABLE order_items CASCADE constraints;
DROP TABLE payments CASCADE constraints;


-- 3. procedury funkcje wyzwalacze obslugujace baze
-- a. dodawanie, usuwanie, aktualizacja rekordow

-- BOOKS

CREATE OR REPLACE PROCEDURE add_book (
    p_title IN books.title%TYPE,
    p_isbn IN books.isbn%TYPE,
    p_author_id IN books.author_id%TYPE,
    p_category_id IN books.category_id%TYPE,
    p_price IN books.price%TYPE,
    p_stock_quantity IN books.stock_quantity%TYPE,
    p_year_of_release IN books.year_of_release%TYPE
)
IS
    e_not_valid_isbn EXCEPTION;
BEGIN
    IF NOT validate_isbn(p_isbn) THEN
        RAISE e_not_valid_isbn;
    END IF;

    INSERT INTO books (title, isbn, author_id, category_id, price, stock_quantity, year_of_release)
    VALUES (p_title, p_isbn, p_author_id, p_category_id, p_price, p_stock_quantity, p_year_of_release);
EXCEPTION
    WHEN e_not_valid_isbn THEN
        DBMS_OUTPUT.PUT_LINE('Blad w add_book, niepoprawny ISBN = ' || p_isbn);
        log_error('Blad w add_book, niepoprawny ISBN = ' || p_isbn);
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Nie można dodać książki: ' || SQLERRM);
        log_error('Blad w trakcie dodawania ksiazki = ' || SQLERRM);
END;
/

-- udane ksiazki

BEGIN
    add_book(
        p_title => 'NowaKsiazkaTest',
        p_isbn => 1234567890199,
        p_author_id => 1,
        p_category_id => 1,
        p_price => 40.00,
        p_stock_quantity => 1,
        p_year_of_release => 2015
    );
END;
/

SELECT * FROM books;
DELETE FROM books WHERE book_id = 11;

-- nieprawidlowe dodanie ksiazki, zbyt mala cena
-- Nie można dodać książki: ORA-02290: check constraint (GRABOWSKAK.CHK_BOOK_PRICE) violated
BEGIN
    add_book(
        p_title => 'NowaKsiazkaTest',
        p_isbn => 1234567890123,
        p_author_id => 1,
        p_category_id => 1,
        p_price => 10.00,
        p_stock_quantity => 1,
        p_year_of_release => 2015
    );
END;
/

SELECT * FROM books;
SELECT * FROM error_log;

-- usuwanie ksiazki z archiwizacja
CREATE OR REPLACE PROCEDURE delete_book (
    p_book_id IN books.book_id%TYPE
)
IS
    e_book_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM books
    WHERE book_id = p_book_id;

    IF v_count = 0 THEN
        RAISE e_book_not_found;
    END IF;

    -- archiwizacja
    INSERT INTO archived_books (book_id, title, isbn, author_id, category_id, price, stock_quantity, year_of_release, archived_at)
    SELECT book_id, title, isbn, author_id, category_id, price, stock_quantity, year_of_release, SYSDATE
    FROM books
    WHERE book_id = p_book_id;

    -- usuniecie
    DELETE FROM books
    WHERE book_id = p_book_id;

    DBMS_OUTPUT.PUT_LINE('Usunieto ksiazke o ID = ' || p_book_id);
EXCEPTION
    WHEN e_book_not_found THEN
        log_error('Ksiazka o ID = ' || p_book_id || ' nie istnieje - DELETE');
        DBMS_OUTPUT.PUT_LINE('Ksiazka o ID = ' || p_book_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad usuniecia ksiazki: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad delete_book: ' || SQLERRM);
END;
/

-- Usunieto ksiazke o ID = 18
BEGIN
    delete_book(18);
END;
/

SELECT * FROM archived_books;

-- Ksiazka o ID = 1000 nie istnieje
BEGIN
    delete_book(1000);
END;
/

SELECT * FROM error_log;


CREATE OR REPLACE PROCEDURE update_book (
    p_book_id          IN books.book_id%TYPE,
    p_title            IN books.title%TYPE,
    p_isbn             IN books.isbn%TYPE,
    p_author_id        IN books.author_id%TYPE,
    p_category_id      IN books.category_id%TYPE,
    p_price            IN books.price%TYPE,
    p_stock_quantity   IN books.stock_quantity%TYPE,
    p_year_of_release  IN books.year_of_release%TYPE
)
IS
    e_not_valid_isbn EXCEPTION;
    e_book_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM books
    WHERE book_id = p_book_id;

    IF v_count = 0 THEN
        RAISE e_book_not_found;
    END IF;

    IF p_isbn IS NOT NULL AND NOT validate_isbn(p_isbn) THEN
        RAISE e_not_valid_isbn;
    END IF;

    -- aktualizacja tych pol ktore nie sa NULL
    UPDATE books
    SET title           = NVL(p_title, title),
        isbn            = NVL(p_isbn, isbn),
        author_id       = NVL(p_author_id, author_id),
        category_id     = p_category_id,
        price           = NVL(p_price, price),
        stock_quantity  = NVL(p_stock_quantity, stock_quantity),
        year_of_release = p_year_of_release
    WHERE book_id = p_book_id;

    DBMS_OUTPUT.PUT_LINE('Zaktualizowano ksiazke o ID = ' || p_author_id);
EXCEPTION
    WHEN e_not_valid_isbn THEN
        DBMS_OUTPUT.PUT_LINE('Blad w add_book, niepoprawny ISBN = ' || p_isbn);
        log_error('Blad w add_book, niepoprawny ISBN = ' || p_isbn);
    WHEN e_book_not_found THEN
        log_error('Ksiazka o ID = ' || p_book_id || ' nie istnieje - UPDATE');
        DBMS_OUTPUT.PUT_LINE('Ksiazka o ID = ' || p_book_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad aktualizacji ksiazki: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad aktualizacji ksiazki: ' || SQLERRM);
END;
/

BEGIN
    update_book(
        p_book_id => 19,
        p_title => 'Nowy Tytul',
        p_isbn => '12345678',
        p_author_id => 2,
        p_category_id => 3,
        p_price => 45,
        p_stock_quantity => 10,
        p_year_of_release => 2025
    );
END;
/

SELECT * FROM books;

-- AUTORZY
-- dodawanie autora
CREATE OR REPLACE PROCEDURE add_author(
    p_author_id   IN authors.author_id%TYPE,
    p_first_name  IN authors.first_name%TYPE,
    p_last_name   IN authors.last_name%TYPE,
    p_birth_year  IN authors.birth_year%TYPE DEFAULT NULL,
    p_death_year  IN authors.death_year%TYPE DEFAULT NULL
)
IS
BEGIN
    INSERT INTO authors(author_id, first_name, last_name, birth_year, death_year)
    VALUES(p_author_id, p_first_name, p_last_name, p_birth_year, p_death_year);
EXCEPTION
    WHEN OTHERS THEN
        log_error('Blad dodawania autora: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad dodawania autora: ' || SQLERRM);
END;
/

BEGIN
    add_author (1000, 'Test', 'Testowy', 1990, 2000);
END;
/

SELECT * FROM authors;

CREATE OR REPLACE PROCEDURE delete_author (
    p_author_id IN authors.author_id%TYPE
)
IS
    e_author_not_found EXCEPTION;
    v_count            NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM authors
    WHERE author_id = p_author_id;
    
    IF v_count = 0 THEN
        RAISE e_author_not_found;
    END IF;
    
    -- archiwizacja
    INSERT INTO archived_authors (author_id, first_name, last_name, birth_year, death_year, archived_at)
    SELECT author_id, first_name, last_name, birth_year, death_year, SYSDATE FROM authors
    WHERE author_id = p_author_id;
    
    -- usuniecie
    DELETE FROM authors 
    WHERE author_id = p_author_id;
    
    DBMS_OUTPUT.PUT_LINE('Usunieto autora o ID = ' || p_author_id);
EXCEPTION
    WHEN e_author_not_found THEN
        log_error('Autor o ID = ' || p_author_id || ' nie istnieje - DELETE');
        DBMS_OUTPUT.PUT_LINE('Autor o ID = ' || p_author_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad usuwania autora: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad usuwania autora: ' || SQLERRM);
END;
/

BEGIN
    delete_author (1000);
END;
/

-- autor o tym ID nie istnieje
-- output: Autor o ID = 100000 nie istnieje
BEGIN
    delete_author (100000);
END;
/

SELECT * FROM authors;
SELECT * FROM archived_authors;


CREATE OR REPLACE PROCEDURE update_author (
    p_author_id IN authors.author_id%TYPE,
    p_first_name IN authors.first_name%TYPE DEFAULT NULL,
    p_last_name IN authors.last_name%TYPE DEFAULT NULL,
    p_birth_year IN authors.birth_year%TYPE DEFAULT NULL,
    p_death_year IN authors.death_year%TYPE DEFAULT NULL
)
IS
    e_author_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM authors
    WHERE author_id = p_author_id;

    IF v_count = 0 THEN
        RAISE e_author_not_found;
    END IF;

    -- aktualizacja tych pol ktore nie sa NULL
    UPDATE authors
    SET first_name = NVL(p_first_name, first_name),
        last_name  = NVL(p_last_name, last_name),
        birth_year = p_birth_year, -- moze byc NULL
        death_year = p_death_year  -- moze byc NULL
    WHERE author_id = p_author_id;

    DBMS_OUTPUT.PUT_LINE('Zaktualizowano autora o ID = ' || p_author_id);
EXCEPTION
    WHEN e_author_not_found THEN
        log_error('Autor o ID = ' || p_author_id || ' nie istnieje - UPDATE');
        DBMS_OUTPUT.PUT_LINE('Autor o ID = ' || p_author_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad aktualizacji autora: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad aktualizacji autora: ' || SQLERRM);
END;
/

BEGIN
    update_author(
        p_author_id => 1000,
        p_first_name => NULL,
        p_last_name => NULL,
        p_birth_year => 2000, 
        p_death_year => 1999
    );
END;
/
SELECT * FROM authors;

-- KATEGORIE
-- kategoria
CREATE OR REPLACE PROCEDURE add_category(
    p_category_id IN categories.category_id%TYPE,
    p_name        IN categories.name%TYPE,
    p_description IN categories.description%TYPE DEFAULT NULL
)
IS
BEGIN
    INSERT INTO categories(category_id, name, description)
    VALUES(p_category_id, p_name, p_description);
EXCEPTION
    WHEN OTHERS THEN
        log_error('Blad dodawania kategorii: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad dodawania kategorii: ' || SQLERRM);
END;
/

BEGIN
    add_category(1000, 'NowaKategoria', 'Testowa kategoria do testow');
END;
/

CREATE OR REPLACE PROCEDURE delete_category(
    p_category_id IN categories.category_id%TYPE
)
IS
    e_category_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM categories 
    WHERE category_id = p_category_id;
    
    IF v_count = 0 THEN
        RAISE e_category_not_found;
    END IF;

    INSERT INTO archived_categories (category_id, name, description, archived_at)
    SELECT category_id, name, description, SYSDATE FROM categories WHERE category_id = p_category_id;

    DELETE FROM categories WHERE category_id = p_category_id;

    DBMS_OUTPUT.PUT_LINE('Usunieto kategorie o ID = ' || p_category_id);
EXCEPTION
    WHEN e_category_not_found THEN
        log_error('Kategoria o ID = ' || p_category_id || ' nie istnieje - DELETE');
        DBMS_OUTPUT.PUT_LINE('Kategoria o ID = ' || p_category_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad usuwania kategorii: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad delete_category: ' || SQLERRM);
END;
/

-- Usunieto kategorie o ID = 1000
BEGIN
    delete_category(1000);
END;
/

CREATE OR REPLACE PROCEDURE update_category(
    p_category_id IN categories.category_id%TYPE,
    p_name        IN categories.name%TYPE DEFAULT NULL,
    p_description IN categories.description%TYPE DEFAULT NULL
)
IS
    e_category_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM categories 
    WHERE category_id = p_category_id;
    
    IF v_count = 0 THEN
        RAISE e_category_not_found;
    END IF;

    UPDATE categories
    SET name        = NVL(p_name, name),
        description = NVL(p_description, description)
    WHERE category_id = p_category_id;

    DBMS_OUTPUT.PUT_LINE('Zaktualizowano kategorie o ID = ' || p_category_id);
EXCEPTION
    WHEN e_category_not_found THEN
        log_error('Kategoria o ID = ' || p_category_id || ' nie istnieje - UPDATE');
        DBMS_OUTPUT.PUT_LINE('Kategoria o ID = ' || p_category_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad aktualizacji kategorii: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad update_category: ' || SQLERRM);
END;
/

-- KLIENCI

CREATE OR REPLACE PROCEDURE add_customer(
    p_first_name IN customers.first_name%TYPE,
    p_last_name  IN customers.last_name%TYPE,
    p_email      IN customers.email%TYPE
)
IS
    e_invalid_email EXCEPTION;
BEGIN
    IF NOT validate_email(p_email) THEN
        RAISE e_invalid_email;
    END IF;
    
    INSERT INTO customers(first_name, last_name, email, registration_date)
    VALUES(p_first_name, p_last_name, p_email, SYSDATE);
    
    DBMS_OUTPUT.PUT_LINE('Dodano klienta: ' || p_first_name || ' ' || p_last_name);
EXCEPTION
    WHEN e_invalid_email THEN
        log_error('Niepoprawny email w add_customer: ' || p_email);
        DBMS_OUTPUT.PUT_LINE('Niepoprawny email w add_customer: ' || p_email);
    WHEN OTHERS THEN
        log_error('Blad dodawania klienta w add_customer: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad dodawania klienta w add_customer: ' || SQLERRM);
END;
/

BEGIN
    add_customer(
        p_first_name => 'Anna',
        p_last_name  => 'Kowalska',
        p_email      => 'anna.kowalska@gmail.com'
    );
END;
/

BEGIN
    add_customer(
        p_first_name => 'Jan',
        p_last_name  => 'Mitczynski',
        p_email      => 'jan.mitczynski@onet.pl'
    );
END;
/

BEGIN
    add_customer(
        p_first_name => 'Oleksandra',
        p_last_name  => 'Polakowska',
        p_email      => 'olek.p@gmail.com'
    );
END;
/

CREATE OR REPLACE PROCEDURE delete_customer(
    p_customer_id IN customers.customer_id%TYPE
)
IS
    e_customer_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM customers 
    WHERE customer_id = p_customer_id;
    
    IF v_count = 0 THEN
        RAISE e_customer_not_found;
    END IF;

    INSERT INTO archived_customers(customer_id, first_name, last_name, email, registration_date, archived_at)
    SELECT customer_id, first_name, last_name, email, registration_date, SYSDATE
    FROM customers
    WHERE customer_id = p_customer_id;

    DELETE FROM customers WHERE customer_id = p_customer_id;

    DBMS_OUTPUT.PUT_LINE('Usunieto klienta o ID = ' || p_customer_id);
EXCEPTION
    WHEN e_customer_not_found THEN
        log_error('Klient o ID = ' || p_customer_id || ' nie istnieje - DELETE');
        DBMS_OUTPUT.PUT_LINE('Klient o ID = ' || p_customer_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad usuwania klienta: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad delete_customer: ' || SQLERRM);
END;
/

CREATE OR REPLACE PROCEDURE update_customer(
    p_customer_id IN customers.customer_id%TYPE,
    p_first_name  IN customers.first_name%TYPE DEFAULT NULL,
    p_last_name   IN customers.last_name%TYPE DEFAULT NULL,
    p_email       IN customers.email%TYPE DEFAULT NULL
)
IS
    e_invalid_email EXCEPTION;
    e_customer_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM customers 
    WHERE customer_id = p_customer_id;
    
    IF v_count = 0 THEN
        RAISE e_customer_not_found;
    END IF;

    IF p_email IS NOT NULL AND NOT validate_email(p_email) THEN
        RAISE e_invalid_email;
    END IF;

    UPDATE customers
    SET first_name = NVL(p_first_name, first_name),
        last_name  = NVL(p_last_name, last_name),
        email      = NVL(p_email, email)
    WHERE customer_id = p_customer_id;

    DBMS_OUTPUT.PUT_LINE('Zaktualizowano klienta o ID = ' || p_customer_id);
EXCEPTION
    WHEN e_invalid_email THEN
        log_error('Niepoprawny email: ' || p_email);
        DBMS_OUTPUT.PUT_LINE('Niepoprawny email: ' || p_email);
    WHEN e_customer_not_found THEN
        log_error('Klient o ID = ' || p_customer_id || ' nie istnieje - UPDATE');
        DBMS_OUTPUT.PUT_LINE('Klient o ID = ' || p_customer_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad aktualizacji klienta: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad update_customer: ' || SQLERRM);
END;
/

-- ORDERS
CREATE OR REPLACE PROCEDURE add_order (
    p_customer_id  IN orders.customer_id%TYPE,
    p_status       IN orders.status%TYPE DEFAULT 'NEW',
    p_order_date  IN orders.order_date%TYPE DEFAULT SYSDATE
)
IS
BEGIN
    INSERT INTO orders (customer_id, status, total_amount, order_date)
    VALUES (p_customer_id, p_status, 0, p_order_date);

    DBMS_OUTPUT.PUT_LINE('Dodano zamowienie dla klienta ID = ' || p_customer_id);
EXCEPTION
    WHEN OTHERS THEN
        log_error('Blad dodawania zamowienia: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad dodawania zamowienia: ' || SQLERRM);
END;
/

BEGIN
    add_order(
        p_customer_id => 3,
        p_order_date  => DATE '2026-02-15'
    );
END;
/

SELECT * FROM orders
WHERE customer_id = 3;

CREATE OR REPLACE PROCEDURE delete_order(
    p_order_id IN orders.order_id%TYPE
)
IS
    e_order_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM orders 
    WHERE order_id = p_order_id;
    
    IF v_count = 0 THEN
        RAISE e_order_not_found;
    END IF;

    INSERT INTO archived_orders
    SELECT orders.*, SYSDATE FROM orders WHERE order_id = p_order_id;

    DELETE FROM orders WHERE order_id = p_order_id;

    DBMS_OUTPUT.PUT_LINE('Usunieto zamowienie o ID = ' || p_order_id);
EXCEPTION
    WHEN e_order_not_found THEN
        log_error('Zamowienie o ID = ' || p_order_id || ' nie istnieje - DELETE');
        DBMS_OUTPUT.PUT_LINE('Zamowienie o ID = ' || p_order_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad usuwania zamowienia: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad delete_order: ' || SQLERRM);
END;
/

Delete from order_items;

CREATE OR REPLACE PROCEDURE update_order(
    p_order_id    IN orders.order_id%TYPE,
    p_customer_id IN orders.customer_id%TYPE DEFAULT NULL,
    p_status      IN orders.status%TYPE DEFAULT NULL,
    p_total_amount IN orders.total_amount%TYPE DEFAULT NULL
)
IS
    e_order_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM orders 
    WHERE order_id = p_order_id;
    
    IF v_count = 0 THEN
        RAISE e_order_not_found;
    END IF;

    UPDATE orders
    SET customer_id = NVL(p_customer_id, customer_id),
        status      = NVL(p_status, status),
        total_amount = NVL(p_total_amount, total_amount)
    WHERE order_id = p_order_id;

    DBMS_OUTPUT.PUT_LINE('Zaktualizowano zamowienie o ID = ' || p_order_id);
EXCEPTION
    WHEN e_order_not_found THEN
        log_error('Zamowienie o ID = ' || p_order_id || ' nie istnieje - UPDATE');
        DBMS_OUTPUT.PUT_LINE('Zamowienie o ID = ' || p_order_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad aktualizacji zamowienia: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad update_order: ' || SQLERRM);
END;
/

-- ORDER ITEM
CREATE OR REPLACE PROCEDURE add_order_item(
    p_order_id   IN order_items.order_id%TYPE,
    p_book_id    IN order_items.book_id%TYPE,
    p_quantity   IN order_items.quantity%TYPE,
    p_unit_price IN order_items.unit_price%TYPE DEFAULT NULL
)
IS
    v_price NUMBER(10,2);
BEGIN
    -- jesli nie podano unit_price to pobierz z books
    IF p_unit_price IS NULL THEN
        SELECT price INTO v_price
        FROM books
        WHERE book_id = p_book_id;
    ELSE
        v_price := p_unit_price;
    END IF;
    
    INSERT INTO order_items(order_id, book_id, quantity, unit_price)
    VALUES(p_order_id, p_book_id, p_quantity, v_price);
    
    DBMS_OUTPUT.PUT_LINE('Dodano pozycje zamowienia: order_id = ' || p_order_id || ', book_id = ' || p_book_id);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Blad: nie znaleziono ksiazki o ID = ' || p_book_id);
        log_error('Nie znaleziono ksiazki o ID = ' || p_book_id);
    WHEN OTHERS THEN
        log_error('Blad dodawania pozycji zamowienia: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad dodawania pozycji zamowienia: ' || SQLERRM);
END;
/

BEGIN
    add_order_item(
        p_order_id => 9,
        p_book_id  => 1,
        p_quantity => 1
    );
--    
--    add_order_item(
--        p_order_id => 4,
--        p_book_id  => 2,
--        p_quantity => 1
--    );
--    
--    add_order_item(
--        p_order_id => 4,
--        p_book_id  => 4,
--        p_quantity => 3
--    );
END;
/

SELECT * FROM order_items;

CREATE OR REPLACE PROCEDURE delete_order_item(
    p_order_item_id IN order_items.order_item_id%TYPE
)
IS
    e_item_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM order_items 
    WHERE order_item_id = p_order_item_id;
    
    IF v_count = 0 THEN
        RAISE e_item_not_found;
    END IF;

    DELETE FROM order_items WHERE order_item_id = p_order_item_id;

    DBMS_OUTPUT.PUT_LINE('Usunieto pozycje zamowienia o ID = ' || p_order_item_id);
EXCEPTION
    WHEN e_item_not_found THEN
        log_error('Pozycja zamowienia o ID = ' || p_order_item_id || ' nie istnieje - DELETE');
        DBMS_OUTPUT.PUT_LINE('Pozycja zamowienia o ID = ' || p_order_item_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad usuwania pozycji zamówienia: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad delete_order_item: ' || SQLERRM);
END;
/

CREATE OR REPLACE PROCEDURE update_order_item(
    p_order_item_id IN order_items.order_item_id%TYPE,
    p_order_id      IN order_items.order_id%TYPE DEFAULT NULL,
    p_book_id       IN order_items.book_id%TYPE DEFAULT NULL,
    p_quantity      IN order_items.quantity%TYPE DEFAULT NULL,
    p_unit_price    IN order_items.unit_price%TYPE DEFAULT NULL
)
IS
    e_item_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM order_items 
    WHERE order_item_id = p_order_item_id;
    
    IF v_count = 0 THEN
        RAISE e_item_not_found;
    END IF;

    UPDATE order_items
    SET order_id   = NVL(p_order_id, order_id),
        book_id    = NVL(p_book_id, book_id),
        quantity   = NVL(p_quantity, quantity),
        unit_price = NVL(p_unit_price, unit_price)
    WHERE order_item_id = p_order_item_id;

    DBMS_OUTPUT.PUT_LINE('Zaktualizowano pozycje zamowienia o ID = ' || p_order_item_id);
EXCEPTION
    WHEN e_item_not_found THEN
        log_error('Pozycja zamowienia o ID = ' || p_order_item_id || ' nie istnieje - UPDATE');
        DBMS_OUTPUT.PUT_LINE('Pozycja zamowienia o ID = ' || p_order_item_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad aktualizacji pozycji zamowienia: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad update_order_item: ' || SQLERRM);
END;
/


-- PAYMENT
CREATE OR REPLACE PROCEDURE add_payment(
    p_order_id      IN payments.order_id%TYPE,
    p_payment_type  IN payments.payment_type%TYPE,
    p_payment_status IN payments.payment_status%TYPE,
    p_payment_date  IN payments.payment_date%TYPE DEFAULT SYSDATE,
    p_amount        IN payments.amount%TYPE
)
IS
BEGIN
    INSERT INTO payments(order_id, payment_type, payment_status, payment_date, amount)
    VALUES(p_order_id, p_payment_type, p_payment_status, p_payment_date, p_amount);
EXCEPTION
    WHEN OTHERS THEN
        log_error('Blad dodawania płatności: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad dodawania płatności: ' || SQLERRM);
END;
/

CREATE OR REPLACE PROCEDURE delete_payment(
    p_payment_id IN payments.payment_id%TYPE
)
IS
    e_payment_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM payments 
    WHERE payment_id = p_payment_id;
    
    IF v_count = 0 THEN
        RAISE e_payment_not_found;
    END IF;

    DELETE FROM payments WHERE payment_id = p_payment_id;

    DBMS_OUTPUT.PUT_LINE('Usunieto platnosc o ID = ' || p_payment_id);
EXCEPTION
    WHEN e_payment_not_found THEN
        log_error('Platnosc o ID = ' || p_payment_id || ' nie istnieje - DELETE');
        DBMS_OUTPUT.PUT_LINE('Platnosc o ID = ' || p_payment_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad usuwania płatności: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad delete_payment: ' || SQLERRM);
END;
/

CREATE OR REPLACE PROCEDURE update_payment(
    p_payment_id      IN payments.payment_id%TYPE,
    p_order_id        IN payments.order_id%TYPE DEFAULT NULL,
    p_payment_type    IN payments.payment_type%TYPE DEFAULT NULL,
    p_payment_status  IN payments.payment_status%TYPE DEFAULT NULL,
    p_payment_date    IN payments.payment_date%TYPE DEFAULT NULL,
    p_amount          IN payments.amount%TYPE DEFAULT NULL
)
IS
    e_payment_not_found EXCEPTION;
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM payments 
    WHERE payment_id = p_payment_id;
    
    IF v_count = 0 THEN
        RAISE e_payment_not_found;
    END IF;

    UPDATE payments
    SET order_id       = NVL(p_order_id, order_id),
        payment_type   = NVL(p_payment_type, payment_type),
        payment_status = NVL(p_payment_status, payment_status),
        payment_date   = NVL(p_payment_date, payment_date),
        amount         = NVL(p_amount, amount)
    WHERE payment_id = p_payment_id;

    DBMS_OUTPUT.PUT_LINE('Zaktualizowano platnosc o ID = ' || p_payment_id);
EXCEPTION
    WHEN e_payment_not_found THEN
        log_error('Platnosc o ID = ' || p_payment_id || ' nie istnieje - UPDATE');
        DBMS_OUTPUT.PUT_LINE('Platnosc o ID = ' || p_payment_id || ' nie istnieje');
    WHEN OTHERS THEN
        log_error('Blad aktualizacji płatności: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Blad update_payment: ' || SQLERRM);
END;
/

-- b. archiwizacja usunietych danych
CREATE TABLE archived_books AS
SELECT * FROM books WHERE 1=0;
ALTER TABLE archived_books ADD archived_at DATE DEFAULT SYSDATE;

CREATE TABLE archived_authors AS
SELECT * FROM authors WHERE 1=0;
ALTER TABLE archived_authors ADD archived_at DATE DEFAULT SYSDATE;

CREATE TABLE archived_categories AS
SELECT * FROM categories WHERE 1=0;
ALTER TABLE archived_categories ADD archived_at DATE DEFAULT SYSDATE;

SELECT * FROM archived_categories;

CREATE TABLE archived_customers AS 
SELECT * FROM customers WHERE 1=0;
ALTER TABLE archived_customers ADD archived_at DATE DEFAULT SYSDATE;

CREATE TABLE archived_orders AS 
SELECT * FROM orders WHERE 1=0;
ALTER TABLE archived_orders ADD archived_at DATE DEFAULT SYSDATE;

-- c. logowanie informacji do tabeli

CREATE TABLE error_log (
    log_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    error_message VARCHAR2(4000),
    error_date    DATE DEFAULT SYSDATE
);

CREATE OR REPLACE PROCEDURE log_error(p_error_message IN VARCHAR2) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    INSERT INTO error_log (error_message, error_date)
    VALUES (p_error_message, SYSDATE);

    COMMIT;
END;
/

-- f. Sprawdzanie poprawnosci dodawanych danych
-- ^ poczatek napisu
-- \d dowolna cyfra
-- 13 cyfr
-- $ koniec napisu
CREATE OR REPLACE FUNCTION validate_isbn(p_isbn IN VARCHAR2) 
    RETURN BOOLEAN 
IS
BEGIN
    IF LENGTH(TRIM(p_isbn)) = 13 AND REGEXP_LIKE(TRIM(p_isbn), '^\d{13}$') THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
/

-- \. kropka oddzielajaca koncowke domeny, co najmniej 2 litery
CREATE OR REPLACE FUNCTION validate_email(p_email IN VARCHAR2) 
    RETURN BOOLEAN 
IS
BEGIN
    RETURN REGEXP_LIKE(TRIM(p_email), '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');
END;
/

-- trigger automatycznie aktualizujacy total_amount w tabeli orders
-- wywolywany INSERT OR UPDATE OR DELETE pozycji zamowienia
-- total_amount = suma (quantity * unit_price)
-- jesli zamowienie nie ma pozycji -> total_amount = 0
CREATE OR REPLACE TRIGGER TRG_UPDATE_ORDER_TOTAL
AFTER INSERT OR UPDATE OR DELETE ON order_items
DECLARE
BEGIN
    -- Aktualizujemy total_amount
    -- NVL(SUM(...),0) -> brak pozycji = 0
    UPDATE orders o
    SET total_amount = (
        SELECT NVL(SUM(quantity * unit_price), 0)
        FROM order_items i
        WHERE i.order_id = o.order_id
    )
    WHERE o.order_id IN (
        SELECT DISTINCT order_id FROM order_items
    );
END;
/


BEGIN
    add_order(p_customer_id => 1);
END;
/
SELECT * FROM orders;

BEGIN
    add_order_item(p_order_id => 3, p_book_id => 4, p_quantity => 3);
    add_order_item(p_order_id => 3, p_book_id => 3, p_quantity => 2);
END;
/

SELECT order_id, total_amount FROM orders WHERE order_id = 2;
select * from order_items;
BEGIN
    delete_order_item(20);
END;
/

-- funkcja okienkowa
-- najczesciej kupowane ksiazki
-- funkcja rank over - nieciagla
SELECT 
    b.book_id,
    b.title,
    SUM(oi.quantity) AS total_sold,
    RANK() OVER (
        ORDER BY SUM(oi.quantity) DESC
    ) AS rank
FROM order_items oi
JOIN books b ON oi.book_id = b.book_id
GROUP BY b.book_id, b.title
ORDER BY rank;

-- laczna kwota zamowien -> najwiecej wydajacy klient
-- dense rank - funkcja ciagla -> szereg zwarty
SELECT 
    c.customer_id,
    c.first_name || ' ' || c.last_name AS customer_name,
    SUM(o.total_amount) AS total_spent,
    DENSE_RANK() OVER (
        ORDER BY SUM(o.total_amount) DESC
        ) AS customer_rank
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY customer_rank;


-- 4. tworzenie zestawienia zapisywanego w bazie danych

CREATE TABLE sales_summary (
    summary_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    period_start   DATE NOT NULL,
    period_end     DATE NOT NULL,
    period_type    VARCHAR2(10) NOT NULL,
    total_orders   NUMBER,
    total_revenue  NUMBER(10,2),
    created_at     DATE DEFAULT SYSDATE,

    CONSTRAINT chk_period_type
        CHECK (period_type IN ('MONTH', 'QUARTER', 'YEAR'))
);


CREATE OR REPLACE PROCEDURE generate_sales_summary (
    p_period_type IN VARCHAR2,   -- 'MONTH', 'QUARTER', 'YEAR'
    p_date        IN DATE        -- data z danego przedzialu
)
IS
    v_start_date   DATE;
    v_end_date     DATE;
    v_orders_count NUMBER;
    v_total    NUMBER(10,2);
BEGIN
    -- zakres daty
    IF p_period_type = 'MONTH' THEN
        v_start_date := TRUNC(p_date, 'MM');
        v_end_date   := LAST_DAY(p_date);

    ELSIF p_period_type = 'QUARTER' THEN
        v_start_date := TRUNC(p_date, 'Q');
        v_end_date   := ADD_MONTHS(TRUNC(p_date, 'Q'), 3) - 1;

    ELSIF p_period_type = 'YEAR' THEN
        v_start_date := TRUNC(p_date, 'YYYY');
        v_end_date   := ADD_MONTHS(TRUNC(p_date, 'YYYY'), 12) - 1;

    ELSE
        RAISE_APPLICATION_ERROR(-20001, 'Niepoprawny period_type');
    END IF;

    -- liczenie danych
    SELECT COUNT(*), NVL(SUM(total_amount), 0)
    INTO v_orders_count, v_total
    FROM orders
    WHERE order_date BETWEEN v_start_date AND v_end_date;

    -- usuwa istniejace
    DELETE FROM sales_summary
    WHERE period_start = v_start_date
      AND period_end   = v_end_date
      AND period_type  = p_period_type;

    -- zapis aktualnego zestawienia do tabeli podsumowań
    INSERT INTO sales_summary (period_start, period_end, period_type, total_orders, total_revenue)
    VALUES (v_start_date, v_end_date, p_period_type, v_orders_count, v_total);

    DBMS_OUTPUT.PUT_LINE('Utworzono zestawienie ' || p_period_type || ' od ' || v_start_date || ' do ' || v_end_date);
END;
/

BEGIN
    generate_sales_summary(
        p_period_type => 'MONTH',
        p_date        => SYSDATE
    );
END;
/

BEGIN
    generate_sales_summary(
        p_period_type => 'MONTH',
        p_date        => DATE '2026-02-01'
    );
END;
/

SELECT * FROM sales_summary;

SELECT
    period_start,
    total_revenue,

    DENSE_RANK() OVER (
        ORDER BY total_revenue DESC
    ) AS revenue_rank
FROM sales_summary
WHERE period_type = 'MONTH';

SELECT
    period_start,
    total_revenue,
    DENSE_RANK() OVER (
        ORDER BY period_start ASC
    ) AS month_rank
FROM sales_summary
WHERE period_type = 'MONTH'
  AND EXTRACT(YEAR FROM period_start) = 2026;

